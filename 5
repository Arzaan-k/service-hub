import { Express } from 'express';
import { ragAdapter } from './services/ragAdapter';

export const registerRoutes = (app: Express) => {
  app.post('/api/rag/query', async (req, res) => {
    try {
      const result = await ragAdapter.query(req.body);
      res.json(result);
    } catch (error) {
      console.error('Error in RAG query:', error);
      res.status(500).json({ message: 'Error processing RAG query' });
    }
  });

  app.get('/api/rag/history', async (req, res) => {
    const userId = req.headers['x-user-id'] as string;
    if (!userId) {
      return res.status(401).json({ message: 'Unauthorized' });
    }
    try {
      const history = await ragAdapter.getUserQueryHistory(userId);
      res.json(history);
    } catch (error) {
      console.error('Error fetching RAG history:', error);
      res.status(500).json({ message: 'Error fetching RAG history' });
    }
  });

<<<<<<< HEAD
  return app;
};
=======
  // RAG diagnosis endpoint (manual-grounded)
  app.post("/api/rag/diagnose", authenticateUser, async (req: any, res) => {
    try {
      const { containerId, alarmCode, unitModel, query } = req.body || {};
      const out = await runDiagnosis({ containerId, alarmCode, unitModel, query });
      res.json(out);
    } catch (e: any) {
      console.error('[RAG] diagnose failed:', e?.message || e);
      res.status(500).json({ error: 'Diagnosis failed' });
    }
  });

  app.post("/api/rag/upload", authenticateUser, requireRole("admin"), upload.single('file'), async (req: AuthRequest, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const { title, description, brand, model } = req.body;
      
      if (!title) {
        return res.status(400).json({ error: "Title is required" });
      }
      
      // Save file to disk
      const fileName = `${Date.now()}-${req.file.originalname}`;
      const filePath = `uploads/manuals/${fileName}`;
      
      fs.mkdirSync('uploads/manuals', { recursive: true });
      fs.writeFileSync(filePath, req.file.buffer);
      
      // Create manual record
      const manualId = await storage.createManual({
        title,
        description: description || '',
        fileName,
        filePath,
        uploadedBy: req.user?.id || '',
        brand: brand || '',
        model: model || '',
      });
      
      // Process document and create embeddings
      const result = await documentProcessor.processPDFFile(filePath, manualId);
      
      res.json({
        success: true,
        manual_id: manualId,
        processing_result: result
      });
    } catch (error) {
      console.error("RAG upload error:", error);
      res.status(500).json({ error: "Failed to process document upload" });
    }
  });

  // Enhanced WebSocket for real-time updates with user authentication
  const wss = new WebSocketServer({ server: httpServer, path: "/ws" });

  interface AuthenticatedWebSocket extends WebSocket {
    userId?: string;
    userRole?: string;
    isAuthenticated?: boolean;
  }

  const clients = new Map<string, AuthenticatedWebSocket>();

  wss.on("connection", (ws: AuthenticatedWebSocket) => {
    ws.isAuthenticated = false;
    console.log("WebSocket client connected");

    ws.on("message", async (data) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === 'authenticate') {
          // Authenticate WebSocket connection
          const { token } = message;
          if (token) {
            // Verify JWT token (simplified for demo)
            const user = await storage.getUser(token);
            if (user) {
              ws.userId = user.id;
              ws.userRole = user.role;
              ws.isAuthenticated = true;
              clients.set(user.id, ws);

              console.log(`WebSocket authenticated for user: ${user.name} (${user.role})`);

              // Send authentication success
              ws.send(JSON.stringify({
                type: 'authenticated',
                user: { id: user.id, name: user.name, role: user.role }
              }));

              // Send recent WhatsApp messages for this user
              const recentMessages = await storage.getRecentWhatsAppMessages(user.id, 50);
              ws.send(JSON.stringify({
                type: 'recent_messages',
                messages: recentMessages
              }));
            } else {
              ws.send(JSON.stringify({ type: 'auth_error', message: 'Invalid token' }));
            }
          }
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on("close", () => {
      if (ws.userId) {
        clients.delete(ws.userId);
      }
      console.log("WebSocket client disconnected");
    });

    // Send heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'heartbeat' }));
      } else {
        clearInterval(heartbeat);
      }
    }, 30000);
  });

  // Enhanced broadcast function with role-based filtering
  function broadcast(data: any, targetUserId?: string, targetRole?: string) {
    clients.forEach((client, userId) => {
      if (client.readyState === WebSocket.OPEN && client.isAuthenticated) {
        // Filter by user or role if specified
        if (targetUserId && userId !== targetUserId) return;
        if (targetRole && client.userRole !== targetRole) return;

        client.send(JSON.stringify(data));
      }
    });
  }

  // Expose broadcast globally for services (e.g., Orbcomm) to emit realtime events
  (global as any).broadcast = broadcast;

  // Broadcast WhatsApp message to specific user or role
  function broadcastWhatsAppMessage(messageData: any, targetUserId?: string, targetRole?: string) {
    broadcast({
      type: 'whatsapp_message',
      timestamp: new Date(),
      data: messageData
    }, targetUserId, targetRole);
  }

  // Global reference for WhatsApp service to use
  ;(global as any).broadcastWhatsAppMessage = broadcastWhatsAppMessage;

  // Auth routes
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ error: "Email and password required" });
      }

      const user = await storage.getUserByEmail(email);
      if (!user) return res.status(401).json({ error: "Invalid credentials" });

      const { comparePasswords } = await import('./services/auth');
      const ok = await comparePasswords(password, user.password || '');
      if (!ok) return res.status(401).json({ error: "Invalid credentials" });

      if (!user.emailVerified) {
        return res.status(403).json({ error: "Email not verified" });
      }

      // Temporary token compatibility using user.id
      res.json({ user, token: user.id });
    } catch (error) {
      res.status(500).json({ error: "Login failed" });
    }
  });

  app.post("/api/auth/register", async (req, res) => {
    try {
      const { name, email, phoneNumber, password, role } = req.body;

      if (!email || !password || !name || !phoneNumber) {
        return res.status(400).json({ error: "Name, email, phone and password are required" });
      }

      const existingEmail = await storage.getUserByEmail(email);
      if (existingEmail) return res.status(400).json({ error: "Email already registered" });

      const existingPhone = await storage.getUserByPhoneNumber(phoneNumber);
      if (existingPhone) return res.status(400).json({ error: "Phone already registered" });

      const { hashPassword, createAndSendEmailOTP } = await import('./services/auth');
      const passwordHash = await hashPassword(password);

      const user = await storage.createUser({
        phoneNumber,
        name,
        email,
        password: passwordHash,
        role: role || "client",
        isActive: true,
        whatsappVerified: false,
        emailVerified: false,
      });

      const emailResult = await createAndSendEmailOTP(user);

      const message = emailResult.success
        ? 'Verification code sent to email'
        : `Account created. ${emailResult.error || 'Check server logs for verification code.'}`;

      res.json({
        user,
        token: user.id,
        message,
        emailSent: emailResult.success,
        verificationCode: emailResult.code // Only for development/debugging
      });
    } catch (error) {
      console.error('Registration error:', error.message);
      res.status(500).json({ error: "Registration failed" });
    }
  });

  // Forgot password (send OTP)
  app.post('/api/auth/forgot-password', async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) return res.status(400).json({ error: 'Email required' });
      const user = await storage.getUserByEmail(email);
      if (!user) return res.status(404).json({ error: 'User not found' });
      const { createAndSendEmailOTP } = await import('./services/auth');
      const emailResult = await createAndSendEmailOTP(user);
      const message = emailResult.success
        ? 'OTP sent to email'
        : `Reset code generated. ${emailResult.error || 'Check server logs for reset code.'}`;
      res.json({
        message,
        emailSent: emailResult.success,
        resetCode: emailResult.code // Only for development/debugging
      });
    } catch (error) {
      res.status(500).json({ error: 'Failed to send OTP' });
    }
  });

  // Reset password with OTP
  app.post('/api/auth/reset-password', async (req, res) => {
    try {
      const { email, code, newPassword } = req.body;
      if (!email || !code || !newPassword) return res.status(400).json({ error: 'Email, code and newPassword required' });
      const user = await storage.getUserByEmail(email);
      if (!user) return res.status(404).json({ error: 'User not found' });
      const { verifyEmailCode, hashPassword } = await import('./services/auth');
      const ok = await verifyEmailCode(user.id, code);
      if (!ok) return res.status(401).json({ error: 'Invalid or expired code' });
      const passwordHash = await hashPassword(newPassword);
      await storage.updateUser(user.id, { password: passwordHash, emailVerified: true } as any);
      res.json({ message: 'Password reset successful' });
    } catch (error) {
      res.status(500).json({ error: 'Failed to reset password' });
    }
  });

  // Email OTP verification
  app.post('/api/auth/verify-email', async (req, res) => {
    try {
      const { email, code } = req.body;
      if (!email || !code) return res.status(400).json({ error: 'Email and code required' });

      const user = await storage.getUserByEmail(email);
      if (!user) return res.status(404).json({ error: 'User not found' });

      const { verifyEmailCode } = await import('./services/auth');
      const ok = await verifyEmailCode(user.id, code);
      if (!ok) return res.status(401).json({ error: 'Invalid or expired code' });

      await storage.updateUser(user.id, { emailVerified: true });
      res.json({ message: 'Email verified', user, token: user.id });
    } catch (error) {
      res.status(500).json({ error: 'Verification failed' });
    }
  });

  // Resend email OTP
  app.post('/api/auth/resend-email', async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) return res.status(400).json({ error: 'Email required' });

      const user = await storage.getUserByEmail(email);
      if (!user) return res.status(404).json({ error: 'User not found' });
      if (user.emailVerified) return res.json({ message: 'Email already verified' });

      const { createAndSendEmailOTP } = await import('./services/auth');
      const emailResult = await createAndSendEmailOTP(user);
      const message = emailResult.success
        ? 'Verification code resent'
        : `Code regenerated. ${emailResult.error || 'Check server logs for verification code.'}`;
      res.json({
        message,
        emailSent: emailResult.success,
        verificationCode: emailResult.code // Only for development/debugging
      });
    } catch (error) {
      res.status(500).json({ error: 'Resend failed' });
    }
  });

  // Test endpoint to get all users (for development only)
  app.get("/api/test/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json(users);
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ error: "Failed to get users" });
    }
  });

  // Test endpoint to create a test user (for development only)
  app.post("/api/test/create-user", async (req, res) => {
    try {
      const testUserId = "test-admin-123";
      
      // Check if user already exists
      const existingUser = await storage.getUser(testUserId);
      if (existingUser) {
        return res.json({ 
          success: true, 
          user: { 
            id: existingUser.id, 
            name: existingUser.name, 
            role: existingUser.role 
          },
          message: "Test user already exists"
        });
      }
      
      const { hashPassword } = await import('./services/auth');
      const defaultPassword = await hashPassword('test123');
      
      const user = await storage.createUser({
        id: testUserId, // Set specific ID for testing
        phoneNumber: '+1234567890',
        name: 'Test Admin',
        email: 'test@example.com',
        password: defaultPassword,
        role: 'admin',
        isActive: true,
        whatsappVerified: false,
        emailVerified: false,
      });
      
      res.json({ 
        success: true, 
        user: { 
          id: user.id, 
          name: user.name, 
          role: user.role 
        } 
      });
    } catch (error) {
      console.error("Test user creation error:", error);
      res.status(500).json({ error: "Failed to create test user", details: error.message });
    }
  });

  // Get current user endpoint
  app.get("/api/auth/me", authenticateUser, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      res.json({
        id: user.id,
        name: user.name,
        email: user.email,
        phoneNumber: user.phoneNumber,
        role: user.role,
        isActive: user.isActive
      });
    } catch (error) {
      console.error("Get current user error:", error);
      res.status(500).json({ error: "Failed to get current user" });
    }
  });

  // Dashboard stats
  app.get("/api/dashboard/stats", authenticateUser, async (req: any, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      // For clients, scope stats to their containers only
      if (role === 'client') {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json({ totalContainers: 0, activeContainers: 0, activeAlerts: 0, pendingServices: 0, fleetUtilization: 0 });

        const containers = await storage.getContainersByCustomer(customer.id);
        const containerIds = new Set(containers.map((c) => c.id));

        const allAlerts = await storage.getAllAlerts();
        const activeAlerts = allAlerts.filter((a) => !a.resolvedAt && containerIds.has(a.containerId)).length;

        const clientSRs = await storage.getServiceRequestsByCustomer(customer.id);
        const pendingServices = clientSRs.filter((sr) => !sr.actualStartTime && !sr.actualEndTime).length;

        const activeContainers = containers.filter((c) => !!c.currentCustomerId).length;
        const totalContainers = containers.length;
        const fleetUtilization = totalContainers ? Math.round((activeContainers / totalContainers) * 100) : 0;

        return res.json({ totalContainers, activeContainers, activeAlerts, pendingServices, fleetUtilization });
      }

      const stats = await storage.getDashboardStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch stats" });
    }
  });

  // Container routes
  // Zod: pagination schema
  const paginationSchema = z.object({
    limit: z.coerce.number().int().min(1).max(100000).default(50),
    offset: z.coerce.number().int().min(0).default(0),
  });

  // Zod: container create/update schema (subset)
  const containerBodySchema = z.object({
    containerCode: z.string().min(1),
    type: z.enum(["refrigerated", "dry", "special", "iot_enabled", "manual"]).optional(),
    hasIot: z.boolean().optional(),
    orbcommDeviceId: z.string().optional(),
    status: z.enum(["active", "in_service", "maintenance", "retired", "in_transit", "for_sale", "sold"]).optional(),
    currentCustomerId: z.string().uuid().optional().nullable(),
    currentLocation: z.any().optional(),
  });

  // Zod: service request create schema (subset)
  const srCreateSchema = z.object({
    containerId: z.string().min(1),
    customerId: z.string().min(1),
    priority: z.enum(["urgent", "high", "normal", "low"]).optional(),
    issueDescription: z.string().min(3),
    estimatedDuration: z.number().int().positive().optional(),
  });

  app.get("/api/containers", authenticateUser, async (req: AuthRequest, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      const isPrivileged = ["admin", "coordinator", "super_admin"].includes(role);
      if (!isPrivileged) {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json([]);
        const own = await storage.getContainersByCustomer(customer.id);
        return res.json(own);
      }
      const containers = await storage.getAllContainers();
      // Optional pagination: only apply if query includes limit or offset
      const hasLimit = Object.prototype.hasOwnProperty.call(req.query, 'limit');
      const hasOffset = Object.prototype.hasOwnProperty.call(req.query, 'offset');
      if (hasLimit || hasOffset) {
        const { limit, offset } = paginationSchema.parse(req.query);
        res.setHeader('x-total-count', String(containers.length));
        return res.json(containers.slice(offset, offset + limit));
      }
      // Default: return full list (backward compatible)
      res.json(containers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch containers" });
    }
  });

  app.get("/api/containers/:id", authenticateUser, async (req, res) => {
    try {
      const container = await storage.getContainer(req.params.id);
      if (!container) {
        return res.status(404).json({ error: "Container not found" });
      }
      // Enforce client scoping: clients can only access their own containers
      const role = ((req as any).user?.role || '').toLowerCase();
      if (role === 'client') {
        const customer = await storage.getCustomerByUserId((req as any).user.id);
        if (!customer || container.currentCustomerId !== customer.id) {
          return res.status(403).json({ error: "Forbidden" });
        }
      }
      res.json(container);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch container" });
    }
  });

  app.post("/api/containers", authenticateUser, requireRole("admin"), async (req: AuthRequest, res) => {
    try {
      const parsed = containerBodySchema.parse(req.body);
      const container = await storage.createContainer(parsed);
      broadcast({ type: "container_created", data: container });
      res.json(container);
    } catch (error) {
      const message = (error as any)?.issues ? "Validation failed" : "Failed to create container";
      res.status(400).json({ error: message, details: (error as any)?.issues });
    }
  });

  app.put("/api/containers/:id", authenticateUser, requireRole("admin"), async (req: AuthRequest, res) => {
    try {
      const parsed = containerBodySchema.partial().parse(req.body);
      const container = await storage.updateContainer(req.params.id, parsed);
      if (!container) {
        return res.status(404).json({ error: "Container not found" });
      }
      broadcast({ type: "container_updated", data: container });
      res.json(container);
    } catch (error) {
      const message = (error as any)?.issues ? "Validation failed" : "Failed to update container";
      res.status(400).json({ error: message, details: (error as any)?.issues });
    }
  });

  // Enhanced Container Management according to PRD
  app.get("/api/containers/:id/location-history", authenticateUser, async (req, res) => {
    try {
      const history = await storage.getContainerLocationHistory(req.params.id);
      res.json(history);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch location history" });
    }
  });

  app.get("/api/containers/:id/service-history", authenticateUser, async (req, res) => {
    try {
      const history = await storage.getContainerServiceHistory(req.params.id);
      res.json(history);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch service history" });
    }
  });

  app.get("/api/containers/:id/metrics", authenticateUser, async (req, res) => {
    try {
      const metrics = await storage.getContainerMetrics(req.params.id);
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch container metrics" });
    }
  });

  app.post("/api/containers/:id/assign", authenticateUser, requireRole("admin"), async (req, res) => {
    try {
      const { customerId, assignmentDate, expectedReturnDate } = req.body;
      const container = await storage.assignContainerToCustomer(
        req.params.id, 
        customerId, 
        assignmentDate, 
        expectedReturnDate
      );
      if (!container) {
        return res.status(404).json({ error: "Container not found" });
      }
      broadcast({ type: "container_assigned", data: container });
      res.json(container);
    } catch (error) {
      res.status(500).json({ error: "Failed to assign container" });
    }
  });

  app.post("/api/containers/:id/unassign", authenticateUser, requireRole("admin"), async (req, res) => {
    try {
      const container = await storage.unassignContainer(req.params.id);
      if (!container) {
        return res.status(404).json({ error: "Container not found" });
      }
      broadcast({ type: "container_unassigned", data: container });
      res.json(container);
    } catch (error) {
      res.status(500).json({ error: "Failed to unassign container" });
    }
  });

  app.get("/api/containers/iot/enabled", authenticateUser, async (req, res) => {
    try {
      const containers = await storage.getIotEnabledContainers();
      res.json(containers);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch IoT containers" });
    }
  });

  app.get("/api/containers/status/:status", authenticateUser, async (req: any, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      const isPrivileged = ["admin", "coordinator", "super_admin"].includes(role);
      if (!isPrivileged) {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json([]);
        const all = await storage.getContainersByStatus(req.params.status);
        return res.json(all.filter((c) => c.currentCustomerId === customer.id));
      }
      const all = await storage.getContainersByStatus(req.params.status);
      res.json(all);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch containers by status" });
    }
  });

  // Alert routes
  app.get("/api/alerts", authenticateUser, async (req: any, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      if (role === 'client') {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json([]);
        const containers = await storage.getContainersByCustomer(customer.id);
        const containerIds = new Set(containers.map((c) => c.id));
        const alerts = await storage.getAllAlerts();
        return res.json(alerts.filter((a) => containerIds.has(a.containerId)));
      }
      const alerts = await storage.getAllAlerts();
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts" });
    }
  });

  app.get("/api/alerts/open", authenticateUser, async (req: any, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      const open = await storage.getOpenAlerts();
      if (role === 'client') {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json([]);
        const containers = await storage.getContainersByCustomer(customer.id);
        const containerIds = new Set(containers.map((c) => c.id));
        return res.json(open.filter((a) => containerIds.has(a.containerId)));
      }
      res.json(open);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch open alerts" });
    }
  });

  app.post("/api/alerts", authenticateUser, async (req, res) => {
    try {
      const { containerId, errorCode, description } = req.body;

      const container = await storage.getContainer(containerId);
      if (!container) {
        return res.status(404).json({ error: "Container not found" });
      }

      // Classify with Gemini AI
      const classification = await classifyAlert(errorCode, description, container);

      const alert = await storage.createAlert({
        alertCode: `ALT-${Date.now()}`,
        containerId,
        severity: classification.severity,
        status: "open",
        title: `${classification.category.replace(/_/g, " ").toUpperCase()}`,
        description,
        aiClassification: classification,
        errorCode,
        detectedAt: new Date(),
        resolutionSteps: classification.resolutionSteps,
        requiredParts: classification.requiredParts,
        estimatedServiceTime: classification.estimatedServiceTime,
      });

      // Send WhatsApp notification if critical/high
      if (["critical", "high"].includes(classification.severity) && container.currentCustomerId) {
        const customer = await storage.getCustomer(container.currentCustomerId);
        if (customer) {
          const customerUser = await storage.getUser(customer.userId);
          if (customerUser) {
            const message = formatAlertMessage(alert, container);
            await sendInteractiveButtons(customerUser.phoneNumber, message, [
              { id: "approve_service", title: "Approve Service" },
              { id: "schedule_later", title: "Schedule Later" },
              { id: "more_info", title: "More Info" },
            ]);
          }
        }
      }

      broadcast({ type: "alert_created", data: alert });
      res.json(alert);
    } catch (error) {
      console.error("Alert creation error:", error);
      res.status(500).json({ error: "Failed to create alert" });
    }
  });

  // Enhanced Alert Management according to PRD
  app.get("/api/alerts/severity/:severity", authenticateUser, async (req, res) => {
    try {
      const alerts = await storage.getAlertsBySeverity(req.params.severity);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts by severity" });
    }
  });

  app.get("/api/alerts/source/:source", authenticateUser, async (req, res) => {
    try {
      const alerts = await storage.getAlertsBySource(req.params.source);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts by source" });
    }
  });

  app.put("/api/alerts/:id/acknowledge", authenticateUser, async (req, res) => {
    try {
      const alert = await storage.acknowledgeAlert(req.params.id, req.user!.id);
      if (!alert) {
        return res.status(404).json({ error: "Alert not found" });
      }
      broadcast({ type: "alert_acknowledged", data: alert });
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to acknowledge alert" });
    }
  });

  app.put("/api/alerts/:id/resolve", authenticateUser, async (req, res) => {
    try {
      const { resolutionMethod = "service" } = req.body;
      const alert = await storage.resolveAlert(req.params.id, resolutionMethod);
      if (!alert) {
        return res.status(404).json({ error: "Alert not found" });
      }
      broadcast({ type: "alert_resolved", data: alert });
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to resolve alert" });
    }
  });

  app.get("/api/alerts/container/:containerId", authenticateUser, async (req, res) => {
    try {
      const alerts = await storage.getAlertsByContainer(req.params.containerId);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch container alerts" });
    }
  });

  // Service Request routes - specific routes first
  app.get("/api/service-requests/pending", authenticateUser, requireRole("admin", "coordinator"), async (req, res) => {
    try {
      const requests = await storage.getPendingServiceRequests();
      res.json(requests);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch pending requests" });
    }
  });

  // Single service request with relations for detail view
  app.get("/api/service-requests/:id", authenticateUser, async (req: AuthRequest, res) => {
    try {
      const id = req.params.id;
      const request = await storage.getServiceRequest(id);
      if (!request) return res.status(404).json({ error: "Not found" });

      const [container, customer, technician] = await Promise.all([
        storage.getContainer(request.containerId),
        storage.getCustomer(request.customerId),
        request.assignedTechnicianId ? storage.getTechnician(request.assignedTechnicianId) : Promise.resolve(undefined)
      ]);

      const response = {
        ...request,
        container: container ? { id: container.id, containerCode: container.containerCode, currentLocation: container.currentLocation } : undefined,
        customer: customer ? { id: customer.id, companyName: customer.companyName } : undefined,
        technician: technician ? { id: technician.id, name: (await storage.getUser(technician.userId))?.name || technician.employeeCode } : undefined,
      };

      res.json(response);
    } catch (error) {
      console.error("Fetch service request detail error:", error);
      res.status(500).json({ error: "Failed to fetch service request detail" });
    }
  });

  // Generic service requests route - must come after specific routes
  app.get("/api/service-requests", authenticateUser, async (req: AuthRequest, res) => {
    try {
      const role = (req.user?.role || '').toLowerCase();
      if (role === 'client') {
        const customer = await storage.getCustomerByUserId(req.user.id);
        if (!customer) return res.json([]);
        const list = await storage.getServiceRequestsByCustomer(customer.id);
        const hasLimit = Object.prototype.hasOwnProperty.call(req.query, 'limit');
        const hasOffset = Object.prototype.hasOwnProperty.call(req.query, 'offset');
        if (hasLimit || hasOffset) {
          const { limit, offset } = paginationSchema.parse(req.query);
          res.setHeader('x-total-count', String(list.length));
          return res.json(list.slice(offset, offset + limit));
        }
        return res.json(list);
      }
      if (role === 'technician') {
        const tech = await storage.getTechnician(req.user.id);
        if (!tech) return res.json([]);
        const list = await storage.getServiceRequestsByTechnician(tech.id);
        const hasLimit = Object.prototype.hasOwnProperty.call(req.query, 'limit');
        const hasOffset = Object.prototype.hasOwnProperty.call(req.query, 'offset');
        if (hasLimit || hasOffset) {
          const { limit, offset } = paginationSchema.parse(req.query);
          res.setHeader('x-total-count', String(list.length));
          return res.json(list.slice(offset, offset + limit));
        }
        return res.json(list);
      }
      const requests = await storage.getAllServiceRequests();
      const hasLimit = Object.prototype.hasOwnProperty.call(req.query, 'limit');
      const hasOffset = Object.prototype.hasOwnProperty.call(req.query, 'offset');
      if (hasLimit || hasOffset) {
        const { limit, offset } = paginationSchema.parse(req.query);
        res.setHeader('x-total-count', String(requests.length));
        return res.json(requests.slice(offset, offset + limit));
      }
      res.json(requests);
    } catch (error) {
      res.status(500).j